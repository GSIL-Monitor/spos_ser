// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lang.proto

package spos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Indicates the type of speech event.
type StreamingRecognizeResponse_SpeechEventType int32

const (
	// No speech event specified.
	StreamingRecognizeResponse_SPEECH_EVENT_UNSPECIFIED StreamingRecognizeResponse_SpeechEventType = 0
	// This event indicates that the server has detected the end of the user's
	// speech utterance and expects no additional speech. Therefore, the server
	// will not process additional audio (although it may subsequently return
	// additional results). The client should stop sending additional audio
	// data, half-close the gRPC connection, and wait for any additional results
	// until the server closes the gRPC connection. This event is only sent if
	// `single_utterance` was set to `true`, and is not used otherwise.
	StreamingRecognizeResponse_END_OF_SINGLE_UTTERANCE StreamingRecognizeResponse_SpeechEventType = 1
)

var StreamingRecognizeResponse_SpeechEventType_name = map[int32]string{
	0: "SPEECH_EVENT_UNSPECIFIED",
	1: "END_OF_SINGLE_UTTERANCE",
}
var StreamingRecognizeResponse_SpeechEventType_value = map[string]int32{
	"SPEECH_EVENT_UNSPECIFIED": 0,
	"END_OF_SINGLE_UTTERANCE":  1,
}

func (x StreamingRecognizeResponse_SpeechEventType) String() string {
	return proto.EnumName(StreamingRecognizeResponse_SpeechEventType_name, int32(x))
}
func (StreamingRecognizeResponse_SpeechEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{13, 0}
}

// Audio encoding of the data sent in the audio message. All encodings support
// only 1 channel (mono) audio. Only `FLAC` and `WAV` include a header that
// describes the bytes of audio that follow the header. The other encodings
// are raw audio bytes with no header.
//
// For best results, the audio source should be captured and transmitted using
// a lossless encoding (`FLAC` or `LINEAR16`). Recognition accuracy may be
// reduced if lossy codecs, which include the other codecs listed in
// this section, are used to capture or transmit the audio, particularly if
// background noise is present.
type RecognitionConfig_AudioEncoding int32

const (
	// Not specified. Will return result [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
	RecognitionConfig_ENCODING_UNSPECIFIED RecognitionConfig_AudioEncoding = 0
	// Uncompressed 16-bit signed little-endian samples (Linear PCM).
	RecognitionConfig_LINEAR16 RecognitionConfig_AudioEncoding = 1
	// [`FLAC`](https://xiph.org/flac/documentation.html) (Free Lossless Audio
	// Codec) is the recommended encoding because it is
	// lossless--therefore recognition is not compromised--and
	// requires only about half the bandwidth of `LINEAR16`. `FLAC` stream
	// encoding supports 16-bit and 24-bit samples, however, not all fields in
	// `STREAMINFO` are supported.
	RecognitionConfig_FLAC RecognitionConfig_AudioEncoding = 2
	// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
	RecognitionConfig_MULAW RecognitionConfig_AudioEncoding = 3
	// Adaptive Multi-Rate Narrowband codec. `sample_rate_hertz` must be 8000.
	RecognitionConfig_AMR RecognitionConfig_AudioEncoding = 4
	// Adaptive Multi-Rate Wideband codec. `sample_rate_hertz` must be 16000.
	RecognitionConfig_AMR_WB RecognitionConfig_AudioEncoding = 5
	// Opus encoded audio frames in Ogg container
	// ([OggOpus](https://wiki.xiph.org/OggOpus)).
	// `sample_rate_hertz` must be 16000.
	RecognitionConfig_OGG_OPUS RecognitionConfig_AudioEncoding = 6
	// Although the use of lossy encodings is not recommended, if a very low
	// bitrate encoding is required, `OGG_OPUS` is highly preferred over
	// Speex encoding. The [Speex](https://speex.org/)  encoding supported by
	// Cloud Speech API has a header byte in each block, as in MIME type
	// `audio/x-speex-with-header-byte`.
	// It is a variant of the RTP Speex encoding defined in
	// [RFC 5574](https://tools.ietf.org/html/rfc5574).
	// The stream is a sequence of blocks, one block per RTP packet. Each block
	// starts with a byte containing the length of the block, in bytes, followed
	// by one or more frames of Speex data, padded to an integral number of
	// bytes (octets) as specified in RFC 5574. In other words, each RTP header
	// is replaced with a single byte containing the block length. Only Speex
	// wideband is supported. `sample_rate_hertz` must be 16000.
	RecognitionConfig_SPEEX_WITH_HEADER_BYTE RecognitionConfig_AudioEncoding = 7
)

var RecognitionConfig_AudioEncoding_name = map[int32]string{
	0: "ENCODING_UNSPECIFIED",
	1: "LINEAR16",
	2: "FLAC",
	3: "MULAW",
	4: "AMR",
	5: "AMR_WB",
	6: "OGG_OPUS",
	7: "SPEEX_WITH_HEADER_BYTE",
}
var RecognitionConfig_AudioEncoding_value = map[string]int32{
	"ENCODING_UNSPECIFIED":   0,
	"LINEAR16":               1,
	"FLAC":                   2,
	"MULAW":                  3,
	"AMR":                    4,
	"AMR_WB":                 5,
	"OGG_OPUS":               6,
	"SPEEX_WITH_HEADER_BYTE": 7,
}

func (x RecognitionConfig_AudioEncoding) String() string {
	return proto.EnumName(RecognitionConfig_AudioEncoding_name, int32(x))
}
func (RecognitionConfig_AudioEncoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{16, 0}
}

//  client login Req
type ClientLoginReq struct {
	Sid                  string   `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Mac                  string   `protobuf:"bytes,4,opt,name=mac,proto3" json:"mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientLoginReq) Reset()         { *m = ClientLoginReq{} }
func (m *ClientLoginReq) String() string { return proto.CompactTextString(m) }
func (*ClientLoginReq) ProtoMessage()    {}
func (*ClientLoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{0}
}
func (m *ClientLoginReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientLoginReq.Unmarshal(m, b)
}
func (m *ClientLoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientLoginReq.Marshal(b, m, deterministic)
}
func (dst *ClientLoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientLoginReq.Merge(dst, src)
}
func (m *ClientLoginReq) XXX_Size() int {
	return xxx_messageInfo_ClientLoginReq.Size(m)
}
func (m *ClientLoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientLoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_ClientLoginReq proto.InternalMessageInfo

func (m *ClientLoginReq) GetSid() string {
	if m != nil {
		return m.Sid
	}
	return ""
}

func (m *ClientLoginReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *ClientLoginReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClientLoginReq) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

type ClientLoginRes struct {
	Ret                  bool     `protobuf:"varint,1,opt,name=ret,proto3" json:"ret,omitempty"`
	ResStr               string   `protobuf:"bytes,2,opt,name=res_str,json=resStr,proto3" json:"res_str,omitempty"`
	ResToken             string   `protobuf:"bytes,3,opt,name=res_token,json=resToken,proto3" json:"res_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientLoginRes) Reset()         { *m = ClientLoginRes{} }
func (m *ClientLoginRes) String() string { return proto.CompactTextString(m) }
func (*ClientLoginRes) ProtoMessage()    {}
func (*ClientLoginRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{1}
}
func (m *ClientLoginRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientLoginRes.Unmarshal(m, b)
}
func (m *ClientLoginRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientLoginRes.Marshal(b, m, deterministic)
}
func (dst *ClientLoginRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientLoginRes.Merge(dst, src)
}
func (m *ClientLoginRes) XXX_Size() int {
	return xxx_messageInfo_ClientLoginRes.Size(m)
}
func (m *ClientLoginRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientLoginRes.DiscardUnknown(m)
}

var xxx_messageInfo_ClientLoginRes proto.InternalMessageInfo

func (m *ClientLoginRes) GetRet() bool {
	if m != nil {
		return m.Ret
	}
	return false
}

func (m *ClientLoginRes) GetResStr() string {
	if m != nil {
		return m.ResStr
	}
	return ""
}

func (m *ClientLoginRes) GetResToken() string {
	if m != nil {
		return m.ResToken
	}
	return ""
}

//  client logout Req
type ClientLogoutReq struct {
	Sid                  string   `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Mac                  string   `protobuf:"bytes,3,opt,name=mac,proto3" json:"mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientLogoutReq) Reset()         { *m = ClientLogoutReq{} }
func (m *ClientLogoutReq) String() string { return proto.CompactTextString(m) }
func (*ClientLogoutReq) ProtoMessage()    {}
func (*ClientLogoutReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{2}
}
func (m *ClientLogoutReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientLogoutReq.Unmarshal(m, b)
}
func (m *ClientLogoutReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientLogoutReq.Marshal(b, m, deterministic)
}
func (dst *ClientLogoutReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientLogoutReq.Merge(dst, src)
}
func (m *ClientLogoutReq) XXX_Size() int {
	return xxx_messageInfo_ClientLogoutReq.Size(m)
}
func (m *ClientLogoutReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientLogoutReq.DiscardUnknown(m)
}

var xxx_messageInfo_ClientLogoutReq proto.InternalMessageInfo

func (m *ClientLogoutReq) GetSid() string {
	if m != nil {
		return m.Sid
	}
	return ""
}

func (m *ClientLogoutReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClientLogoutReq) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

type ClientLogoutRes struct {
	Ret                  bool     `protobuf:"varint,1,opt,name=ret,proto3" json:"ret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientLogoutRes) Reset()         { *m = ClientLogoutRes{} }
func (m *ClientLogoutRes) String() string { return proto.CompactTextString(m) }
func (*ClientLogoutRes) ProtoMessage()    {}
func (*ClientLogoutRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{3}
}
func (m *ClientLogoutRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientLogoutRes.Unmarshal(m, b)
}
func (m *ClientLogoutRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientLogoutRes.Marshal(b, m, deterministic)
}
func (dst *ClientLogoutRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientLogoutRes.Merge(dst, src)
}
func (m *ClientLogoutRes) XXX_Size() int {
	return xxx_messageInfo_ClientLogoutRes.Size(m)
}
func (m *ClientLogoutRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientLogoutRes.DiscardUnknown(m)
}

var xxx_messageInfo_ClientLogoutRes proto.InternalMessageInfo

func (m *ClientLogoutRes) GetRet() bool {
	if m != nil {
		return m.Ret
	}
	return false
}

//  client heart Req
type ClientHeartReq struct {
	Sid                  string   `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Mac                  string   `protobuf:"bytes,2,opt,name=mac,proto3" json:"mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientHeartReq) Reset()         { *m = ClientHeartReq{} }
func (m *ClientHeartReq) String() string { return proto.CompactTextString(m) }
func (*ClientHeartReq) ProtoMessage()    {}
func (*ClientHeartReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{4}
}
func (m *ClientHeartReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientHeartReq.Unmarshal(m, b)
}
func (m *ClientHeartReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientHeartReq.Marshal(b, m, deterministic)
}
func (dst *ClientHeartReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientHeartReq.Merge(dst, src)
}
func (m *ClientHeartReq) XXX_Size() int {
	return xxx_messageInfo_ClientHeartReq.Size(m)
}
func (m *ClientHeartReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientHeartReq.DiscardUnknown(m)
}

var xxx_messageInfo_ClientHeartReq proto.InternalMessageInfo

func (m *ClientHeartReq) GetSid() string {
	if m != nil {
		return m.Sid
	}
	return ""
}

func (m *ClientHeartReq) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

type ClientHeartRes struct {
	Ret                  bool     `protobuf:"varint,1,opt,name=ret,proto3" json:"ret,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientHeartRes) Reset()         { *m = ClientHeartRes{} }
func (m *ClientHeartRes) String() string { return proto.CompactTextString(m) }
func (*ClientHeartRes) ProtoMessage()    {}
func (*ClientHeartRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{5}
}
func (m *ClientHeartRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientHeartRes.Unmarshal(m, b)
}
func (m *ClientHeartRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientHeartRes.Marshal(b, m, deterministic)
}
func (dst *ClientHeartRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientHeartRes.Merge(dst, src)
}
func (m *ClientHeartRes) XXX_Size() int {
	return xxx_messageInfo_ClientHeartRes.Size(m)
}
func (m *ClientHeartRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientHeartRes.DiscardUnknown(m)
}

var xxx_messageInfo_ClientHeartRes proto.InternalMessageInfo

func (m *ClientHeartRes) GetRet() bool {
	if m != nil {
		return m.Ret
	}
	return false
}

func (m *ClientHeartRes) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// The request message containing the text lang gender audio_code
type TtsReq struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Lang                 string   `protobuf:"bytes,2,opt,name=lang,proto3" json:"lang,omitempty"`
	Gender               int32    `protobuf:"varint,3,opt,name=gender,proto3" json:"gender,omitempty"`
	AudioCode            int32    `protobuf:"varint,4,opt,name=audio_code,json=audioCode,proto3" json:"audio_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TtsReq) Reset()         { *m = TtsReq{} }
func (m *TtsReq) String() string { return proto.CompactTextString(m) }
func (*TtsReq) ProtoMessage()    {}
func (*TtsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{6}
}
func (m *TtsReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TtsReq.Unmarshal(m, b)
}
func (m *TtsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TtsReq.Marshal(b, m, deterministic)
}
func (dst *TtsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TtsReq.Merge(dst, src)
}
func (m *TtsReq) XXX_Size() int {
	return xxx_messageInfo_TtsReq.Size(m)
}
func (m *TtsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TtsReq.DiscardUnknown(m)
}

var xxx_messageInfo_TtsReq proto.InternalMessageInfo

func (m *TtsReq) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *TtsReq) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *TtsReq) GetGender() int32 {
	if m != nil {
		return m.Gender
	}
	return 0
}

func (m *TtsReq) GetAudioCode() int32 {
	if m != nil {
		return m.AudioCode
	}
	return 0
}

// The response message containing the audio data
type TtsReply struct {
	AudioData            []byte   `protobuf:"bytes,1,opt,name=audio_data,json=audioData,proto3" json:"audio_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TtsReply) Reset()         { *m = TtsReply{} }
func (m *TtsReply) String() string { return proto.CompactTextString(m) }
func (*TtsReply) ProtoMessage()    {}
func (*TtsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{7}
}
func (m *TtsReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TtsReply.Unmarshal(m, b)
}
func (m *TtsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TtsReply.Marshal(b, m, deterministic)
}
func (dst *TtsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TtsReply.Merge(dst, src)
}
func (m *TtsReply) XXX_Size() int {
	return xxx_messageInfo_TtsReply.Size(m)
}
func (m *TtsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TtsReply.DiscardUnknown(m)
}

var xxx_messageInfo_TtsReply proto.InternalMessageInfo

func (m *TtsReply) GetAudioData() []byte {
	if m != nil {
		return m.AudioData
	}
	return nil
}

type TransReq struct {
	SLn                  string   `protobuf:"bytes,1,opt,name=s_ln,json=sLn,proto3" json:"s_ln,omitempty"`
	TLn                  string   `protobuf:"bytes,2,opt,name=t_ln,json=tLn,proto3" json:"t_ln,omitempty"`
	Text                 string   `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransReq) Reset()         { *m = TransReq{} }
func (m *TransReq) String() string { return proto.CompactTextString(m) }
func (*TransReq) ProtoMessage()    {}
func (*TransReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{8}
}
func (m *TransReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransReq.Unmarshal(m, b)
}
func (m *TransReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransReq.Marshal(b, m, deterministic)
}
func (dst *TransReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransReq.Merge(dst, src)
}
func (m *TransReq) XXX_Size() int {
	return xxx_messageInfo_TransReq.Size(m)
}
func (m *TransReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TransReq.DiscardUnknown(m)
}

var xxx_messageInfo_TransReq proto.InternalMessageInfo

func (m *TransReq) GetSLn() string {
	if m != nil {
		return m.SLn
	}
	return ""
}

func (m *TransReq) GetTLn() string {
	if m != nil {
		return m.TLn
	}
	return ""
}

func (m *TransReq) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type TransReply struct {
	TransText            string   `protobuf:"bytes,1,opt,name=trans_text,json=transText,proto3" json:"trans_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransReply) Reset()         { *m = TransReply{} }
func (m *TransReply) String() string { return proto.CompactTextString(m) }
func (*TransReply) ProtoMessage()    {}
func (*TransReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{9}
}
func (m *TransReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransReply.Unmarshal(m, b)
}
func (m *TransReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransReply.Marshal(b, m, deterministic)
}
func (dst *TransReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransReply.Merge(dst, src)
}
func (m *TransReply) XXX_Size() int {
	return xxx_messageInfo_TransReply.Size(m)
}
func (m *TransReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TransReply.DiscardUnknown(m)
}

var xxx_messageInfo_TransReply proto.InternalMessageInfo

func (m *TransReply) GetTransText() string {
	if m != nil {
		return m.TransText
	}
	return ""
}

type StreamingRecognizeRequest struct {
	// The streaming request, which is either a streaming config or audio content.
	//
	// Types that are valid to be assigned to StreamingRequest:
	//	*StreamingRecognizeRequest_StreamingConfig
	//	*StreamingRecognizeRequest_AudioContent
	StreamingRequest     isStreamingRecognizeRequest_StreamingRequest `protobuf_oneof:"streaming_request"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *StreamingRecognizeRequest) Reset()         { *m = StreamingRecognizeRequest{} }
func (m *StreamingRecognizeRequest) String() string { return proto.CompactTextString(m) }
func (*StreamingRecognizeRequest) ProtoMessage()    {}
func (*StreamingRecognizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{10}
}
func (m *StreamingRecognizeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecognizeRequest.Unmarshal(m, b)
}
func (m *StreamingRecognizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecognizeRequest.Marshal(b, m, deterministic)
}
func (dst *StreamingRecognizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecognizeRequest.Merge(dst, src)
}
func (m *StreamingRecognizeRequest) XXX_Size() int {
	return xxx_messageInfo_StreamingRecognizeRequest.Size(m)
}
func (m *StreamingRecognizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecognizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecognizeRequest proto.InternalMessageInfo

type isStreamingRecognizeRequest_StreamingRequest interface {
	isStreamingRecognizeRequest_StreamingRequest()
}

type StreamingRecognizeRequest_StreamingConfig struct {
	StreamingConfig *StreamingRecognitionConfig `protobuf:"bytes,1,opt,name=streaming_config,json=streamingConfig,proto3,oneof"`
}
type StreamingRecognizeRequest_AudioContent struct {
	AudioContent []byte `protobuf:"bytes,2,opt,name=audio_content,json=audioContent,proto3,oneof"`
}

func (*StreamingRecognizeRequest_StreamingConfig) isStreamingRecognizeRequest_StreamingRequest() {}
func (*StreamingRecognizeRequest_AudioContent) isStreamingRecognizeRequest_StreamingRequest()    {}

func (m *StreamingRecognizeRequest) GetStreamingRequest() isStreamingRecognizeRequest_StreamingRequest {
	if m != nil {
		return m.StreamingRequest
	}
	return nil
}

func (m *StreamingRecognizeRequest) GetStreamingConfig() *StreamingRecognitionConfig {
	if x, ok := m.GetStreamingRequest().(*StreamingRecognizeRequest_StreamingConfig); ok {
		return x.StreamingConfig
	}
	return nil
}

func (m *StreamingRecognizeRequest) GetAudioContent() []byte {
	if x, ok := m.GetStreamingRequest().(*StreamingRecognizeRequest_AudioContent); ok {
		return x.AudioContent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamingRecognizeRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamingRecognizeRequest_OneofMarshaler, _StreamingRecognizeRequest_OneofUnmarshaler, _StreamingRecognizeRequest_OneofSizer, []interface{}{
		(*StreamingRecognizeRequest_StreamingConfig)(nil),
		(*StreamingRecognizeRequest_AudioContent)(nil),
	}
}

func _StreamingRecognizeRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamingRecognizeRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *StreamingRecognizeRequest_StreamingConfig:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamingConfig); err != nil {
			return err
		}
	case *StreamingRecognizeRequest_AudioContent:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.AudioContent)
	case nil:
	default:
		return fmt.Errorf("StreamingRecognizeRequest.StreamingRequest has unexpected type %T", x)
	}
	return nil
}

func _StreamingRecognizeRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamingRecognizeRequest)
	switch tag {
	case 1: // streaming_request.streaming_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamingRecognitionConfig)
		err := b.DecodeMessage(msg)
		m.StreamingRequest = &StreamingRecognizeRequest_StreamingConfig{msg}
		return true, err
	case 2: // streaming_request.audio_content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.StreamingRequest = &StreamingRecognizeRequest_AudioContent{x}
		return true, err
	default:
		return false, nil
	}
}

func _StreamingRecognizeRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamingRecognizeRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *StreamingRecognizeRequest_StreamingConfig:
		s := proto.Size(x.StreamingConfig)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamingRecognizeRequest_AudioContent:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.AudioContent)))
		n += len(x.AudioContent)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StreamingRecgTransTtsRequest struct {
	// The streaming request, which is either a streaming config or audio content.
	//
	// Types that are valid to be assigned to StreamingRequest:
	//	*StreamingRecgTransTtsRequest_StreamingConfig
	//	*StreamingRecgTransTtsRequest_AudioContent
	StreamingRequest     isStreamingRecgTransTtsRequest_StreamingRequest `protobuf_oneof:"streaming_request"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *StreamingRecgTransTtsRequest) Reset()         { *m = StreamingRecgTransTtsRequest{} }
func (m *StreamingRecgTransTtsRequest) String() string { return proto.CompactTextString(m) }
func (*StreamingRecgTransTtsRequest) ProtoMessage()    {}
func (*StreamingRecgTransTtsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{11}
}
func (m *StreamingRecgTransTtsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecgTransTtsRequest.Unmarshal(m, b)
}
func (m *StreamingRecgTransTtsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecgTransTtsRequest.Marshal(b, m, deterministic)
}
func (dst *StreamingRecgTransTtsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecgTransTtsRequest.Merge(dst, src)
}
func (m *StreamingRecgTransTtsRequest) XXX_Size() int {
	return xxx_messageInfo_StreamingRecgTransTtsRequest.Size(m)
}
func (m *StreamingRecgTransTtsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecgTransTtsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecgTransTtsRequest proto.InternalMessageInfo

type isStreamingRecgTransTtsRequest_StreamingRequest interface {
	isStreamingRecgTransTtsRequest_StreamingRequest()
}

type StreamingRecgTransTtsRequest_StreamingConfig struct {
	StreamingConfig *StreamingRecgTransTtsConfig `protobuf:"bytes,1,opt,name=streaming_config,json=streamingConfig,proto3,oneof"`
}
type StreamingRecgTransTtsRequest_AudioContent struct {
	AudioContent []byte `protobuf:"bytes,2,opt,name=audio_content,json=audioContent,proto3,oneof"`
}

func (*StreamingRecgTransTtsRequest_StreamingConfig) isStreamingRecgTransTtsRequest_StreamingRequest() {
}
func (*StreamingRecgTransTtsRequest_AudioContent) isStreamingRecgTransTtsRequest_StreamingRequest() {}

func (m *StreamingRecgTransTtsRequest) GetStreamingRequest() isStreamingRecgTransTtsRequest_StreamingRequest {
	if m != nil {
		return m.StreamingRequest
	}
	return nil
}

func (m *StreamingRecgTransTtsRequest) GetStreamingConfig() *StreamingRecgTransTtsConfig {
	if x, ok := m.GetStreamingRequest().(*StreamingRecgTransTtsRequest_StreamingConfig); ok {
		return x.StreamingConfig
	}
	return nil
}

func (m *StreamingRecgTransTtsRequest) GetAudioContent() []byte {
	if x, ok := m.GetStreamingRequest().(*StreamingRecgTransTtsRequest_AudioContent); ok {
		return x.AudioContent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamingRecgTransTtsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamingRecgTransTtsRequest_OneofMarshaler, _StreamingRecgTransTtsRequest_OneofUnmarshaler, _StreamingRecgTransTtsRequest_OneofSizer, []interface{}{
		(*StreamingRecgTransTtsRequest_StreamingConfig)(nil),
		(*StreamingRecgTransTtsRequest_AudioContent)(nil),
	}
}

func _StreamingRecgTransTtsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamingRecgTransTtsRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *StreamingRecgTransTtsRequest_StreamingConfig:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamingConfig); err != nil {
			return err
		}
	case *StreamingRecgTransTtsRequest_AudioContent:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.AudioContent)
	case nil:
	default:
		return fmt.Errorf("StreamingRecgTransTtsRequest.StreamingRequest has unexpected type %T", x)
	}
	return nil
}

func _StreamingRecgTransTtsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamingRecgTransTtsRequest)
	switch tag {
	case 1: // streaming_request.streaming_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamingRecgTransTtsConfig)
		err := b.DecodeMessage(msg)
		m.StreamingRequest = &StreamingRecgTransTtsRequest_StreamingConfig{msg}
		return true, err
	case 2: // streaming_request.audio_content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.StreamingRequest = &StreamingRecgTransTtsRequest_AudioContent{x}
		return true, err
	default:
		return false, nil
	}
}

func _StreamingRecgTransTtsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamingRecgTransTtsRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *StreamingRecgTransTtsRequest_StreamingConfig:
		s := proto.Size(x.StreamingConfig)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamingRecgTransTtsRequest_AudioContent:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.AudioContent)))
		n += len(x.AudioContent)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StreamingRecTranTTsResponse struct {
	// Types that are valid to be assigned to StreamingResponse:
	//	*StreamingRecTranTTsResponse_Recg
	//	*StreamingRecTranTTsResponse_TransText
	//	*StreamingRecTranTTsResponse_AudioData
	StreamingResponse    isStreamingRecTranTTsResponse_StreamingResponse `protobuf_oneof:"streaming_response"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *StreamingRecTranTTsResponse) Reset()         { *m = StreamingRecTranTTsResponse{} }
func (m *StreamingRecTranTTsResponse) String() string { return proto.CompactTextString(m) }
func (*StreamingRecTranTTsResponse) ProtoMessage()    {}
func (*StreamingRecTranTTsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{12}
}
func (m *StreamingRecTranTTsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecTranTTsResponse.Unmarshal(m, b)
}
func (m *StreamingRecTranTTsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecTranTTsResponse.Marshal(b, m, deterministic)
}
func (dst *StreamingRecTranTTsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecTranTTsResponse.Merge(dst, src)
}
func (m *StreamingRecTranTTsResponse) XXX_Size() int {
	return xxx_messageInfo_StreamingRecTranTTsResponse.Size(m)
}
func (m *StreamingRecTranTTsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecTranTTsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecTranTTsResponse proto.InternalMessageInfo

type isStreamingRecTranTTsResponse_StreamingResponse interface {
	isStreamingRecTranTTsResponse_StreamingResponse()
}

type StreamingRecTranTTsResponse_Recg struct {
	Recg *StreamingRecognizeResponse `protobuf:"bytes,1,opt,name=recg,proto3,oneof"`
}
type StreamingRecTranTTsResponse_TransText struct {
	TransText []byte `protobuf:"bytes,2,opt,name=trans_text,json=transText,proto3,oneof"`
}
type StreamingRecTranTTsResponse_AudioData struct {
	AudioData []byte `protobuf:"bytes,3,opt,name=audio_data,json=audioData,proto3,oneof"`
}

func (*StreamingRecTranTTsResponse_Recg) isStreamingRecTranTTsResponse_StreamingResponse()      {}
func (*StreamingRecTranTTsResponse_TransText) isStreamingRecTranTTsResponse_StreamingResponse() {}
func (*StreamingRecTranTTsResponse_AudioData) isStreamingRecTranTTsResponse_StreamingResponse() {}

func (m *StreamingRecTranTTsResponse) GetStreamingResponse() isStreamingRecTranTTsResponse_StreamingResponse {
	if m != nil {
		return m.StreamingResponse
	}
	return nil
}

func (m *StreamingRecTranTTsResponse) GetRecg() *StreamingRecognizeResponse {
	if x, ok := m.GetStreamingResponse().(*StreamingRecTranTTsResponse_Recg); ok {
		return x.Recg
	}
	return nil
}

func (m *StreamingRecTranTTsResponse) GetTransText() []byte {
	if x, ok := m.GetStreamingResponse().(*StreamingRecTranTTsResponse_TransText); ok {
		return x.TransText
	}
	return nil
}

func (m *StreamingRecTranTTsResponse) GetAudioData() []byte {
	if x, ok := m.GetStreamingResponse().(*StreamingRecTranTTsResponse_AudioData); ok {
		return x.AudioData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamingRecTranTTsResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamingRecTranTTsResponse_OneofMarshaler, _StreamingRecTranTTsResponse_OneofUnmarshaler, _StreamingRecTranTTsResponse_OneofSizer, []interface{}{
		(*StreamingRecTranTTsResponse_Recg)(nil),
		(*StreamingRecTranTTsResponse_TransText)(nil),
		(*StreamingRecTranTTsResponse_AudioData)(nil),
	}
}

func _StreamingRecTranTTsResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamingRecTranTTsResponse)
	// streaming_response
	switch x := m.StreamingResponse.(type) {
	case *StreamingRecTranTTsResponse_Recg:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Recg); err != nil {
			return err
		}
	case *StreamingRecTranTTsResponse_TransText:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.TransText)
	case *StreamingRecTranTTsResponse_AudioData:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.AudioData)
	case nil:
	default:
		return fmt.Errorf("StreamingRecTranTTsResponse.StreamingResponse has unexpected type %T", x)
	}
	return nil
}

func _StreamingRecTranTTsResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamingRecTranTTsResponse)
	switch tag {
	case 1: // streaming_response.recg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamingRecognizeResponse)
		err := b.DecodeMessage(msg)
		m.StreamingResponse = &StreamingRecTranTTsResponse_Recg{msg}
		return true, err
	case 2: // streaming_response.trans_text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.StreamingResponse = &StreamingRecTranTTsResponse_TransText{x}
		return true, err
	case 3: // streaming_response.audio_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.StreamingResponse = &StreamingRecTranTTsResponse_AudioData{x}
		return true, err
	default:
		return false, nil
	}
}

func _StreamingRecTranTTsResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamingRecTranTTsResponse)
	// streaming_response
	switch x := m.StreamingResponse.(type) {
	case *StreamingRecTranTTsResponse_Recg:
		s := proto.Size(x.Recg)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamingRecTranTTsResponse_TransText:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.TransText)))
		n += len(x.TransText)
	case *StreamingRecTranTTsResponse_AudioData:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.AudioData)))
		n += len(x.AudioData)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StreamingRecognizeResponse struct {
	// *Output-only* If set, returns a [google.rpc.Status][google.rpc.Status] message that
	// specifies the error for the operation.
	Error *Status `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// *Output-only* This repeated list contains zero or more results that
	// correspond to consecutive portions of the audio currently being processed.
	// It contains zero or more `is_final=false` results followed by zero or one
	// `is_final=true` result (the newly settled portion).
	Results []*StreamingRecognitionResult `protobuf:"bytes,2,rep,name=results,proto3" json:"results,omitempty"`
	// *Output-only* Indicates the type of speech event.
	SpeechEventType      StreamingRecognizeResponse_SpeechEventType `protobuf:"varint,4,opt,name=speech_event_type,json=speechEventType,proto3,enum=spos.StreamingRecognizeResponse_SpeechEventType" json:"speech_event_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *StreamingRecognizeResponse) Reset()         { *m = StreamingRecognizeResponse{} }
func (m *StreamingRecognizeResponse) String() string { return proto.CompactTextString(m) }
func (*StreamingRecognizeResponse) ProtoMessage()    {}
func (*StreamingRecognizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{13}
}
func (m *StreamingRecognizeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecognizeResponse.Unmarshal(m, b)
}
func (m *StreamingRecognizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecognizeResponse.Marshal(b, m, deterministic)
}
func (dst *StreamingRecognizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecognizeResponse.Merge(dst, src)
}
func (m *StreamingRecognizeResponse) XXX_Size() int {
	return xxx_messageInfo_StreamingRecognizeResponse.Size(m)
}
func (m *StreamingRecognizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecognizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecognizeResponse proto.InternalMessageInfo

func (m *StreamingRecognizeResponse) GetError() *Status {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *StreamingRecognizeResponse) GetResults() []*StreamingRecognitionResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *StreamingRecognizeResponse) GetSpeechEventType() StreamingRecognizeResponse_SpeechEventType {
	if m != nil {
		return m.SpeechEventType
	}
	return StreamingRecognizeResponse_SPEECH_EVENT_UNSPECIFIED
}

type StreamingRecgTransTtsConfig struct {
	// *Required* Provides information to the recognizer that specifies how to
	// process the request.
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	// *Optional* If `false` or omitted, the recognizer will perform continuous
	// recognition (continuing to wait for and process audio even if the user
	// pauses speaking) until the client closes the input stream (gRPC API) or
	// until the maximum time limit has been reached. May return multiple
	// `StreamingRecognitionResult`s with the `is_final` flag set to `true`.
	//
	// If `true`, the recognizer will detect a single spoken utterance. When it
	// detects that the user has paused or stopped speaking, it will return an
	// `END_OF_SINGLE_UTTERANCE` event and cease recognition. It will return no
	// more than one `StreamingRecognitionResult` with the `is_final` flag set to
	// `true`.
	SingleUtterance bool `protobuf:"varint,2,opt,name=single_utterance,json=singleUtterance,proto3" json:"single_utterance,omitempty"`
	// *Optional* If `true`, interim results (tentative hypotheses) may be
	// returned as they become available (these interim results are indicated with
	// the `is_final=false` flag).
	// If `false` or omitted, only `is_final=true` result(s) are returned.
	InterimResults       bool     `protobuf:"varint,3,opt,name=interim_results,json=interimResults,proto3" json:"interim_results,omitempty"`
	TransSoure           string   `protobuf:"bytes,4,opt,name=trans_soure,json=transSoure,proto3" json:"trans_soure,omitempty"`
	TransTarget          string   `protobuf:"bytes,5,opt,name=trans_target,json=transTarget,proto3" json:"trans_target,omitempty"`
	TtsLn                string   `protobuf:"bytes,6,opt,name=tts_ln,json=ttsLn,proto3" json:"tts_ln,omitempty"`
	TtsGender            int32    `protobuf:"varint,7,opt,name=tts_gender,json=ttsGender,proto3" json:"tts_gender,omitempty"`
	TtsAudioCode         int32    `protobuf:"varint,8,opt,name=tts_audio_code,json=ttsAudioCode,proto3" json:"tts_audio_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamingRecgTransTtsConfig) Reset()         { *m = StreamingRecgTransTtsConfig{} }
func (m *StreamingRecgTransTtsConfig) String() string { return proto.CompactTextString(m) }
func (*StreamingRecgTransTtsConfig) ProtoMessage()    {}
func (*StreamingRecgTransTtsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{14}
}
func (m *StreamingRecgTransTtsConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecgTransTtsConfig.Unmarshal(m, b)
}
func (m *StreamingRecgTransTtsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecgTransTtsConfig.Marshal(b, m, deterministic)
}
func (dst *StreamingRecgTransTtsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecgTransTtsConfig.Merge(dst, src)
}
func (m *StreamingRecgTransTtsConfig) XXX_Size() int {
	return xxx_messageInfo_StreamingRecgTransTtsConfig.Size(m)
}
func (m *StreamingRecgTransTtsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecgTransTtsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecgTransTtsConfig proto.InternalMessageInfo

func (m *StreamingRecgTransTtsConfig) GetConfig() *RecognitionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *StreamingRecgTransTtsConfig) GetSingleUtterance() bool {
	if m != nil {
		return m.SingleUtterance
	}
	return false
}

func (m *StreamingRecgTransTtsConfig) GetInterimResults() bool {
	if m != nil {
		return m.InterimResults
	}
	return false
}

func (m *StreamingRecgTransTtsConfig) GetTransSoure() string {
	if m != nil {
		return m.TransSoure
	}
	return ""
}

func (m *StreamingRecgTransTtsConfig) GetTransTarget() string {
	if m != nil {
		return m.TransTarget
	}
	return ""
}

func (m *StreamingRecgTransTtsConfig) GetTtsLn() string {
	if m != nil {
		return m.TtsLn
	}
	return ""
}

func (m *StreamingRecgTransTtsConfig) GetTtsGender() int32 {
	if m != nil {
		return m.TtsGender
	}
	return 0
}

func (m *StreamingRecgTransTtsConfig) GetTtsAudioCode() int32 {
	if m != nil {
		return m.TtsAudioCode
	}
	return 0
}

type StreamingRecognitionConfig struct {
	// *Required* Provides information to the recognizer that specifies how to
	// process the request.
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	// *Optional* If `false` or omitted, the recognizer will perform continuous
	// recognition (continuing to wait for and process audio even if the user
	// pauses speaking) until the client closes the input stream (gRPC API) or
	// until the maximum time limit has been reached. May return multiple
	// `StreamingRecognitionResult`s with the `is_final` flag set to `true`.
	//
	// If `true`, the recognizer will detect a single spoken utterance. When it
	// detects that the user has paused or stopped speaking, it will return an
	// `END_OF_SINGLE_UTTERANCE` event and cease recognition. It will return no
	// more than one `StreamingRecognitionResult` with the `is_final` flag set to
	// `true`.
	SingleUtterance bool `protobuf:"varint,2,opt,name=single_utterance,json=singleUtterance,proto3" json:"single_utterance,omitempty"`
	// *Optional* If `true`, interim results (tentative hypotheses) may be
	// returned as they become available (these interim results are indicated with
	// the `is_final=false` flag).
	// If `false` or omitted, only `is_final=true` result(s) are returned.
	InterimResults       bool     `protobuf:"varint,3,opt,name=interim_results,json=interimResults,proto3" json:"interim_results,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamingRecognitionConfig) Reset()         { *m = StreamingRecognitionConfig{} }
func (m *StreamingRecognitionConfig) String() string { return proto.CompactTextString(m) }
func (*StreamingRecognitionConfig) ProtoMessage()    {}
func (*StreamingRecognitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{15}
}
func (m *StreamingRecognitionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecognitionConfig.Unmarshal(m, b)
}
func (m *StreamingRecognitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecognitionConfig.Marshal(b, m, deterministic)
}
func (dst *StreamingRecognitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecognitionConfig.Merge(dst, src)
}
func (m *StreamingRecognitionConfig) XXX_Size() int {
	return xxx_messageInfo_StreamingRecognitionConfig.Size(m)
}
func (m *StreamingRecognitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecognitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecognitionConfig proto.InternalMessageInfo

func (m *StreamingRecognitionConfig) GetConfig() *RecognitionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *StreamingRecognitionConfig) GetSingleUtterance() bool {
	if m != nil {
		return m.SingleUtterance
	}
	return false
}

func (m *StreamingRecognitionConfig) GetInterimResults() bool {
	if m != nil {
		return m.InterimResults
	}
	return false
}

// Provides information to the recognizer that specifies how to process the
// request.
type RecognitionConfig struct {
	// *Required* Encoding of audio data sent in all `RecognitionAudio` messages.
	Encoding RecognitionConfig_AudioEncoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=spos.RecognitionConfig_AudioEncoding" json:"encoding,omitempty"`
	// *Required* Sample rate in Hertz of the audio data sent in all
	// `RecognitionAudio` messages. Valid values are: 8000-48000.
	// 16000 is optimal. For best results, set the sampling rate of the audio
	// source to 16000 Hz. If that's not possible, use the native sample rate of
	// the audio source (instead of re-sampling).
	SampleRateHertz int32 `protobuf:"varint,2,opt,name=sample_rate_hertz,json=sampleRateHertz,proto3" json:"sample_rate_hertz,omitempty"`
	// *Required* The language of the supplied audio as a
	// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
	// Example: "en-US".
	// See [Language Support](https://cloud.google.com/speech/docs/languages)
	// for a list of the currently supported language codes.
	LanguageCode string `protobuf:"bytes,3,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
	// *Optional* Maximum number of recognition hypotheses to be returned.
	// Specifically, the maximum number of `SpeechRecognitionAlternative` messages
	// within each `SpeechRecognitionResult`.
	// The server may return fewer than `max_alternatives`.
	// Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
	// one. If omitted, will return a maximum of one.
	MaxAlternatives int32 `protobuf:"varint,4,opt,name=max_alternatives,json=maxAlternatives,proto3" json:"max_alternatives,omitempty"`
	// *Optional* If set to `true`, the server will attempt to filter out
	// profanities, replacing all but the initial character in each filtered word
	// with asterisks, e.g. "f***". If set to `false` or omitted, profanities
	// won't be filtered out.
	ProfanityFilter bool `protobuf:"varint,5,opt,name=profanity_filter,json=profanityFilter,proto3" json:"profanity_filter,omitempty"`
	// *Optional* A means to provide context to assist the speech recognition.
	SpeechContexts []*SpeechContext `protobuf:"bytes,6,rep,name=speech_contexts,json=speechContexts,proto3" json:"speech_contexts,omitempty"`
	// *Optional* If `true`, the top result includes a list of words and
	// the start and end time offsets (timestamps) for those words. If
	// `false`, no word-level time offset information is returned. The default is
	// `false`.
	EnableWordTimeOffsets bool     `protobuf:"varint,8,opt,name=enable_word_time_offsets,json=enableWordTimeOffsets,proto3" json:"enable_word_time_offsets,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *RecognitionConfig) Reset()         { *m = RecognitionConfig{} }
func (m *RecognitionConfig) String() string { return proto.CompactTextString(m) }
func (*RecognitionConfig) ProtoMessage()    {}
func (*RecognitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{16}
}
func (m *RecognitionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognitionConfig.Unmarshal(m, b)
}
func (m *RecognitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognitionConfig.Marshal(b, m, deterministic)
}
func (dst *RecognitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionConfig.Merge(dst, src)
}
func (m *RecognitionConfig) XXX_Size() int {
	return xxx_messageInfo_RecognitionConfig.Size(m)
}
func (m *RecognitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionConfig proto.InternalMessageInfo

func (m *RecognitionConfig) GetEncoding() RecognitionConfig_AudioEncoding {
	if m != nil {
		return m.Encoding
	}
	return RecognitionConfig_ENCODING_UNSPECIFIED
}

func (m *RecognitionConfig) GetSampleRateHertz() int32 {
	if m != nil {
		return m.SampleRateHertz
	}
	return 0
}

func (m *RecognitionConfig) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

func (m *RecognitionConfig) GetMaxAlternatives() int32 {
	if m != nil {
		return m.MaxAlternatives
	}
	return 0
}

func (m *RecognitionConfig) GetProfanityFilter() bool {
	if m != nil {
		return m.ProfanityFilter
	}
	return false
}

func (m *RecognitionConfig) GetSpeechContexts() []*SpeechContext {
	if m != nil {
		return m.SpeechContexts
	}
	return nil
}

func (m *RecognitionConfig) GetEnableWordTimeOffsets() bool {
	if m != nil {
		return m.EnableWordTimeOffsets
	}
	return false
}

type SpeechContext struct {
	// *Optional* A list of strings containing words and phrases "hints" so that
	// the speech recognition is more likely to recognize them. This can be used
	// to improve the accuracy for specific words and phrases, for example, if
	// specific commands are typically spoken by the user. This can also be used
	// to add additional words to the vocabulary of the recognizer. See
	// [usage limits](https://cloud.google.com/speech/limits#content).
	Phrases              []string `protobuf:"bytes,1,rep,name=phrases,proto3" json:"phrases,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpeechContext) Reset()         { *m = SpeechContext{} }
func (m *SpeechContext) String() string { return proto.CompactTextString(m) }
func (*SpeechContext) ProtoMessage()    {}
func (*SpeechContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{17}
}
func (m *SpeechContext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SpeechContext.Unmarshal(m, b)
}
func (m *SpeechContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SpeechContext.Marshal(b, m, deterministic)
}
func (dst *SpeechContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpeechContext.Merge(dst, src)
}
func (m *SpeechContext) XXX_Size() int {
	return xxx_messageInfo_SpeechContext.Size(m)
}
func (m *SpeechContext) XXX_DiscardUnknown() {
	xxx_messageInfo_SpeechContext.DiscardUnknown(m)
}

var xxx_messageInfo_SpeechContext proto.InternalMessageInfo

func (m *SpeechContext) GetPhrases() []string {
	if m != nil {
		return m.Phrases
	}
	return nil
}

type StreamingRecognitionResult struct {
	// *Output-only* May contain one or more recognition hypotheses (up to the
	// maximum specified in `max_alternatives`).
	Alternatives []*SpeechRecognitionAlternative `protobuf:"bytes,1,rep,name=alternatives,proto3" json:"alternatives,omitempty"`
	// *Output-only* If `false`, this `StreamingRecognitionResult` represents an
	// interim result that may change. If `true`, this is the final time the
	// speech service will return this particular `StreamingRecognitionResult`,
	// the recognizer will not return any further hypotheses for this portion of
	// the transcript and corresponding audio.
	IsFinal bool `protobuf:"varint,2,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
	// *Output-only* An estimate of the likelihood that the recognizer will not
	// change its guess about this interim result. Values range from 0.0
	// (completely unstable) to 1.0 (completely stable).
	// This field is only provided for interim results (`is_final=false`).
	// The default of 0.0 is a sentinel value indicating `stability` was not set.
	Stability            float32  `protobuf:"fixed32,3,opt,name=stability,proto3" json:"stability,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamingRecognitionResult) Reset()         { *m = StreamingRecognitionResult{} }
func (m *StreamingRecognitionResult) String() string { return proto.CompactTextString(m) }
func (*StreamingRecognitionResult) ProtoMessage()    {}
func (*StreamingRecognitionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{18}
}
func (m *StreamingRecognitionResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecognitionResult.Unmarshal(m, b)
}
func (m *StreamingRecognitionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecognitionResult.Marshal(b, m, deterministic)
}
func (dst *StreamingRecognitionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecognitionResult.Merge(dst, src)
}
func (m *StreamingRecognitionResult) XXX_Size() int {
	return xxx_messageInfo_StreamingRecognitionResult.Size(m)
}
func (m *StreamingRecognitionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecognitionResult.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecognitionResult proto.InternalMessageInfo

func (m *StreamingRecognitionResult) GetAlternatives() []*SpeechRecognitionAlternative {
	if m != nil {
		return m.Alternatives
	}
	return nil
}

func (m *StreamingRecognitionResult) GetIsFinal() bool {
	if m != nil {
		return m.IsFinal
	}
	return false
}

func (m *StreamingRecognitionResult) GetStability() float32 {
	if m != nil {
		return m.Stability
	}
	return 0
}

type Status struct {
	// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// A developer-facing error message, which should be in English. Any
	// user-facing error message should be localized and sent in the
	// [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// A list of messages that carry the error details.  There will be a
	// common set of message types for APIs to use.
	Details              []*Any   `protobuf:"bytes,3,rep,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{19}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Status.Unmarshal(m, b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Status.Marshal(b, m, deterministic)
}
func (dst *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(dst, src)
}
func (m *Status) XXX_Size() int {
	return xxx_messageInfo_Status.Size(m)
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Status) GetDetails() []*Any {
	if m != nil {
		return m.Details
	}
	return nil
}

type SpeechRecognitionAlternative struct {
	// *Output-only* Transcript text representing the words that the user spoke.
	Transcript string `protobuf:"bytes,1,opt,name=transcript,proto3" json:"transcript,omitempty"`
	// *Output-only* The confidence estimate between 0.0 and 1.0. A higher number
	// indicates an estimated greater likelihood that the recognized words are
	// correct. This field is typically provided only for the top hypothesis, and
	// only for `is_final=true` results. Clients should not rely on the
	// `confidence` field as it is not guaranteed to be accurate or consistent.
	// The default of 0.0 is a sentinel value indicating `confidence` was not set.
	Confidence float32 `protobuf:"fixed32,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// *Output-only* A list of word-specific information for each recognized word.
	Words                []*WordInfo `protobuf:"bytes,3,rep,name=words,proto3" json:"words,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SpeechRecognitionAlternative) Reset()         { *m = SpeechRecognitionAlternative{} }
func (m *SpeechRecognitionAlternative) String() string { return proto.CompactTextString(m) }
func (*SpeechRecognitionAlternative) ProtoMessage()    {}
func (*SpeechRecognitionAlternative) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{20}
}
func (m *SpeechRecognitionAlternative) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SpeechRecognitionAlternative.Unmarshal(m, b)
}
func (m *SpeechRecognitionAlternative) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SpeechRecognitionAlternative.Marshal(b, m, deterministic)
}
func (dst *SpeechRecognitionAlternative) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpeechRecognitionAlternative.Merge(dst, src)
}
func (m *SpeechRecognitionAlternative) XXX_Size() int {
	return xxx_messageInfo_SpeechRecognitionAlternative.Size(m)
}
func (m *SpeechRecognitionAlternative) XXX_DiscardUnknown() {
	xxx_messageInfo_SpeechRecognitionAlternative.DiscardUnknown(m)
}

var xxx_messageInfo_SpeechRecognitionAlternative proto.InternalMessageInfo

func (m *SpeechRecognitionAlternative) GetTranscript() string {
	if m != nil {
		return m.Transcript
	}
	return ""
}

func (m *SpeechRecognitionAlternative) GetConfidence() float32 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *SpeechRecognitionAlternative) GetWords() []*WordInfo {
	if m != nil {
		return m.Words
	}
	return nil
}

type WordInfo struct {
	// *Output-only* Time offset relative to the beginning of the audio,
	// and corresponding to the start of the spoken word.
	// This field is only set if `enable_word_time_offsets=true` and only
	// in the top hypothesis.
	// This is an experimental feature and the accuracy of the time offset can
	// vary.
	StartTime *Duration `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// *Output-only* Time offset relative to the beginning of the audio,
	// and corresponding to the end of the spoken word.
	// This field is only set if `enable_word_time_offsets=true` and only
	// in the top hypothesis.
	// This is an experimental feature and the accuracy of the time offset can
	// vary.
	EndTime *Duration `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// *Output-only* The word corresponding to this set of information.
	Word                 string   `protobuf:"bytes,3,opt,name=word,proto3" json:"word,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WordInfo) Reset()         { *m = WordInfo{} }
func (m *WordInfo) String() string { return proto.CompactTextString(m) }
func (*WordInfo) ProtoMessage()    {}
func (*WordInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{21}
}
func (m *WordInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WordInfo.Unmarshal(m, b)
}
func (m *WordInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WordInfo.Marshal(b, m, deterministic)
}
func (dst *WordInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WordInfo.Merge(dst, src)
}
func (m *WordInfo) XXX_Size() int {
	return xxx_messageInfo_WordInfo.Size(m)
}
func (m *WordInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WordInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WordInfo proto.InternalMessageInfo

func (m *WordInfo) GetStartTime() *Duration {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *WordInfo) GetEndTime() *Duration {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *WordInfo) GetWord() string {
	if m != nil {
		return m.Word
	}
	return ""
}

type Any struct {
	// A URL/resource name that uniquely identifies the type of the serialized
	// protocol buffer message. The last segment of the URL's path must represent
	// the fully qualified name of the type (as in
	// `path/google.protobuf.Duration`). The name should be in a canonical form
	// (e.g., leading "." is not accepted).
	//
	// In practice, teams usually precompile into the binary all types that they
	// expect it to use in the context of Any. However, for URLs which use the
	// scheme `http`, `https`, or no scheme, one can optionally set up a type
	// server that maps type URLs to message definitions as follows:
	//
	// * If no scheme is provided, `https` is assumed.
	// * An HTTP GET on the URL must yield a [google.protobuf.Type][]
	//   value in binary format, or produce an error.
	// * Applications are allowed to cache lookup results based on the
	//   URL, or have them precompiled into a binary to avoid any
	//   lookup. Therefore, binary compatibility needs to be preserved
	//   on changes to types. (Use versioned type names to manage
	//   breaking changes.)
	//
	// Note: this functionality is not currently available in the official
	// protobuf release, and it is not used for type URLs beginning with
	// type.googleapis.com.
	//
	// Schemes other than `http`, `https` (or the empty scheme) might be
	// used with implementation specific semantics.
	//
	TypeUrl string `protobuf:"bytes,1,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
	// Must be a valid serialized protocol buffer of the above specified type.
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Any) Reset()         { *m = Any{} }
func (m *Any) String() string { return proto.CompactTextString(m) }
func (*Any) ProtoMessage()    {}
func (*Any) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{22}
}
func (m *Any) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Any.Unmarshal(m, b)
}
func (m *Any) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Any.Marshal(b, m, deterministic)
}
func (dst *Any) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Any.Merge(dst, src)
}
func (m *Any) XXX_Size() int {
	return xxx_messageInfo_Any.Size(m)
}
func (m *Any) XXX_DiscardUnknown() {
	xxx_messageInfo_Any.DiscardUnknown(m)
}

var xxx_messageInfo_Any proto.InternalMessageInfo

func (m *Any) GetTypeUrl() string {
	if m != nil {
		return m.TypeUrl
	}
	return ""
}

func (m *Any) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type Duration struct {
	// Signed seconds of the span of time. Must be from -315,576,000,000
	// to +315,576,000,000 inclusive. Note: these bounds are computed from:
	// 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Signed fractions of a second at nanosecond resolution of the span
	// of time. Durations less than one second are represented with a 0
	// `seconds` field and a positive or negative `nanos` field. For durations
	// of one second or more, a non-zero value for the `nanos` field must be
	// of the same sign as the `seconds` field. Must be from -999,999,999
	// to +999,999,999 inclusive.
	Nanos                int32    `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Duration) Reset()         { *m = Duration{} }
func (m *Duration) String() string { return proto.CompactTextString(m) }
func (*Duration) ProtoMessage()    {}
func (*Duration) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{23}
}
func (m *Duration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Duration.Unmarshal(m, b)
}
func (m *Duration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Duration.Marshal(b, m, deterministic)
}
func (dst *Duration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Duration.Merge(dst, src)
}
func (m *Duration) XXX_Size() int {
	return xxx_messageInfo_Duration.Size(m)
}
func (m *Duration) XXX_DiscardUnknown() {
	xxx_messageInfo_Duration.DiscardUnknown(m)
}

var xxx_messageInfo_Duration proto.InternalMessageInfo

func (m *Duration) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Duration) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

// The request message containing the user's name.
type HelloRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HelloRequest) Reset()         { *m = HelloRequest{} }
func (m *HelloRequest) String() string { return proto.CompactTextString(m) }
func (*HelloRequest) ProtoMessage()    {}
func (*HelloRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{24}
}
func (m *HelloRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HelloRequest.Unmarshal(m, b)
}
func (m *HelloRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HelloRequest.Marshal(b, m, deterministic)
}
func (dst *HelloRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloRequest.Merge(dst, src)
}
func (m *HelloRequest) XXX_Size() int {
	return xxx_messageInfo_HelloRequest.Size(m)
}
func (m *HelloRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HelloRequest proto.InternalMessageInfo

func (m *HelloRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// The response message containing the greetings
type HelloReply struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HelloReply) Reset()         { *m = HelloReply{} }
func (m *HelloReply) String() string { return proto.CompactTextString(m) }
func (*HelloReply) ProtoMessage()    {}
func (*HelloReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_lang_4a58467c005c656f, []int{25}
}
func (m *HelloReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HelloReply.Unmarshal(m, b)
}
func (m *HelloReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HelloReply.Marshal(b, m, deterministic)
}
func (dst *HelloReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloReply.Merge(dst, src)
}
func (m *HelloReply) XXX_Size() int {
	return xxx_messageInfo_HelloReply.Size(m)
}
func (m *HelloReply) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloReply.DiscardUnknown(m)
}

var xxx_messageInfo_HelloReply proto.InternalMessageInfo

func (m *HelloReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*ClientLoginReq)(nil), "spos.ClientLoginReq")
	proto.RegisterType((*ClientLoginRes)(nil), "spos.ClientLoginRes")
	proto.RegisterType((*ClientLogoutReq)(nil), "spos.ClientLogoutReq")
	proto.RegisterType((*ClientLogoutRes)(nil), "spos.ClientLogoutRes")
	proto.RegisterType((*ClientHeartReq)(nil), "spos.ClientHeartReq")
	proto.RegisterType((*ClientHeartRes)(nil), "spos.ClientHeartRes")
	proto.RegisterType((*TtsReq)(nil), "spos.TtsReq")
	proto.RegisterType((*TtsReply)(nil), "spos.TtsReply")
	proto.RegisterType((*TransReq)(nil), "spos.TransReq")
	proto.RegisterType((*TransReply)(nil), "spos.TransReply")
	proto.RegisterType((*StreamingRecognizeRequest)(nil), "spos.StreamingRecognizeRequest")
	proto.RegisterType((*StreamingRecgTransTtsRequest)(nil), "spos.StreamingRecgTransTtsRequest")
	proto.RegisterType((*StreamingRecTranTTsResponse)(nil), "spos.StreamingRecTranTTsResponse")
	proto.RegisterType((*StreamingRecognizeResponse)(nil), "spos.StreamingRecognizeResponse")
	proto.RegisterType((*StreamingRecgTransTtsConfig)(nil), "spos.StreamingRecgTransTtsConfig")
	proto.RegisterType((*StreamingRecognitionConfig)(nil), "spos.StreamingRecognitionConfig")
	proto.RegisterType((*RecognitionConfig)(nil), "spos.RecognitionConfig")
	proto.RegisterType((*SpeechContext)(nil), "spos.SpeechContext")
	proto.RegisterType((*StreamingRecognitionResult)(nil), "spos.StreamingRecognitionResult")
	proto.RegisterType((*Status)(nil), "spos.Status")
	proto.RegisterType((*SpeechRecognitionAlternative)(nil), "spos.SpeechRecognitionAlternative")
	proto.RegisterType((*WordInfo)(nil), "spos.WordInfo")
	proto.RegisterType((*Any)(nil), "spos.Any")
	proto.RegisterType((*Duration)(nil), "spos.Duration")
	proto.RegisterType((*HelloRequest)(nil), "spos.HelloRequest")
	proto.RegisterType((*HelloReply)(nil), "spos.HelloReply")
	proto.RegisterEnum("spos.StreamingRecognizeResponse_SpeechEventType", StreamingRecognizeResponse_SpeechEventType_name, StreamingRecognizeResponse_SpeechEventType_value)
	proto.RegisterEnum("spos.RecognitionConfig_AudioEncoding", RecognitionConfig_AudioEncoding_name, RecognitionConfig_AudioEncoding_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LangClient is the client API for Lang service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LangClient interface {
	// tts req
	Login(ctx context.Context, in *ClientLoginReq, opts ...grpc.CallOption) (*ClientLoginRes, error)
	Logout(ctx context.Context, in *ClientLogoutReq, opts ...grpc.CallOption) (*ClientLogoutRes, error)
	HeartMsg(ctx context.Context, in *ClientHeartReq, opts ...grpc.CallOption) (*ClientHeartRes, error)
	TtsRequest(ctx context.Context, in *TtsReq, opts ...grpc.CallOption) (Lang_TtsRequestClient, error)
	TransRequest(ctx context.Context, in *TransReq, opts ...grpc.CallOption) (*TransReply, error)
	StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Lang_StreamingRecognizeClient, error)
	StreamingRecTransTTs(ctx context.Context, opts ...grpc.CallOption) (Lang_StreamingRecTransTTsClient, error)
	// Sends a greeting
	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}

type langClient struct {
	cc *grpc.ClientConn
}

func NewLangClient(cc *grpc.ClientConn) LangClient {
	return &langClient{cc}
}

func (c *langClient) Login(ctx context.Context, in *ClientLoginReq, opts ...grpc.CallOption) (*ClientLoginRes, error) {
	out := new(ClientLoginRes)
	err := c.cc.Invoke(ctx, "/spos.Lang/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langClient) Logout(ctx context.Context, in *ClientLogoutReq, opts ...grpc.CallOption) (*ClientLogoutRes, error) {
	out := new(ClientLogoutRes)
	err := c.cc.Invoke(ctx, "/spos.Lang/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langClient) HeartMsg(ctx context.Context, in *ClientHeartReq, opts ...grpc.CallOption) (*ClientHeartRes, error) {
	out := new(ClientHeartRes)
	err := c.cc.Invoke(ctx, "/spos.Lang/HeartMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langClient) TtsRequest(ctx context.Context, in *TtsReq, opts ...grpc.CallOption) (Lang_TtsRequestClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Lang_serviceDesc.Streams[0], "/spos.Lang/TtsRequest", opts...)
	if err != nil {
		return nil, err
	}
	x := &langTtsRequestClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lang_TtsRequestClient interface {
	Recv() (*TtsReply, error)
	grpc.ClientStream
}

type langTtsRequestClient struct {
	grpc.ClientStream
}

func (x *langTtsRequestClient) Recv() (*TtsReply, error) {
	m := new(TtsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *langClient) TransRequest(ctx context.Context, in *TransReq, opts ...grpc.CallOption) (*TransReply, error) {
	out := new(TransReply)
	err := c.cc.Invoke(ctx, "/spos.Lang/TransRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langClient) StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Lang_StreamingRecognizeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Lang_serviceDesc.Streams[1], "/spos.Lang/StreamingRecognize", opts...)
	if err != nil {
		return nil, err
	}
	x := &langStreamingRecognizeClient{stream}
	return x, nil
}

type Lang_StreamingRecognizeClient interface {
	Send(*StreamingRecognizeRequest) error
	Recv() (*StreamingRecognizeResponse, error)
	grpc.ClientStream
}

type langStreamingRecognizeClient struct {
	grpc.ClientStream
}

func (x *langStreamingRecognizeClient) Send(m *StreamingRecognizeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *langStreamingRecognizeClient) Recv() (*StreamingRecognizeResponse, error) {
	m := new(StreamingRecognizeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *langClient) StreamingRecTransTTs(ctx context.Context, opts ...grpc.CallOption) (Lang_StreamingRecTransTTsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Lang_serviceDesc.Streams[2], "/spos.Lang/StreamingRecTransTTs", opts...)
	if err != nil {
		return nil, err
	}
	x := &langStreamingRecTransTTsClient{stream}
	return x, nil
}

type Lang_StreamingRecTransTTsClient interface {
	Send(*StreamingRecgTransTtsRequest) error
	Recv() (*StreamingRecTranTTsResponse, error)
	grpc.ClientStream
}

type langStreamingRecTransTTsClient struct {
	grpc.ClientStream
}

func (x *langStreamingRecTransTTsClient) Send(m *StreamingRecgTransTtsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *langStreamingRecTransTTsClient) Recv() (*StreamingRecTranTTsResponse, error) {
	m := new(StreamingRecTranTTsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *langClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
	out := new(HelloReply)
	err := c.cc.Invoke(ctx, "/spos.Lang/SayHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LangServer is the server API for Lang service.
type LangServer interface {
	// tts req
	Login(context.Context, *ClientLoginReq) (*ClientLoginRes, error)
	Logout(context.Context, *ClientLogoutReq) (*ClientLogoutRes, error)
	HeartMsg(context.Context, *ClientHeartReq) (*ClientHeartRes, error)
	TtsRequest(*TtsReq, Lang_TtsRequestServer) error
	TransRequest(context.Context, *TransReq) (*TransReply, error)
	StreamingRecognize(Lang_StreamingRecognizeServer) error
	StreamingRecTransTTs(Lang_StreamingRecTransTTsServer) error
	// Sends a greeting
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
}

func RegisterLangServer(s *grpc.Server, srv LangServer) {
	s.RegisterService(&_Lang_serviceDesc, srv)
}

func _Lang_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spos.Lang/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangServer).Login(ctx, req.(*ClientLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lang_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientLogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spos.Lang/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangServer).Logout(ctx, req.(*ClientLogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lang_HeartMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientHeartReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangServer).HeartMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spos.Lang/HeartMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangServer).HeartMsg(ctx, req.(*ClientHeartReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lang_TtsRequest_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TtsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LangServer).TtsRequest(m, &langTtsRequestServer{stream})
}

type Lang_TtsRequestServer interface {
	Send(*TtsReply) error
	grpc.ServerStream
}

type langTtsRequestServer struct {
	grpc.ServerStream
}

func (x *langTtsRequestServer) Send(m *TtsReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Lang_TransRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangServer).TransRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spos.Lang/TransRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangServer).TransRequest(ctx, req.(*TransReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lang_StreamingRecognize_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LangServer).StreamingRecognize(&langStreamingRecognizeServer{stream})
}

type Lang_StreamingRecognizeServer interface {
	Send(*StreamingRecognizeResponse) error
	Recv() (*StreamingRecognizeRequest, error)
	grpc.ServerStream
}

type langStreamingRecognizeServer struct {
	grpc.ServerStream
}

func (x *langStreamingRecognizeServer) Send(m *StreamingRecognizeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *langStreamingRecognizeServer) Recv() (*StreamingRecognizeRequest, error) {
	m := new(StreamingRecognizeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Lang_StreamingRecTransTTs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LangServer).StreamingRecTransTTs(&langStreamingRecTransTTsServer{stream})
}

type Lang_StreamingRecTransTTsServer interface {
	Send(*StreamingRecTranTTsResponse) error
	Recv() (*StreamingRecgTransTtsRequest, error)
	grpc.ServerStream
}

type langStreamingRecTransTTsServer struct {
	grpc.ServerStream
}

func (x *langStreamingRecTransTTsServer) Send(m *StreamingRecTranTTsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *langStreamingRecTransTTsServer) Recv() (*StreamingRecgTransTtsRequest, error) {
	m := new(StreamingRecgTransTtsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Lang_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangServer).SayHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spos.Lang/SayHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangServer).SayHello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Lang_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spos.Lang",
	HandlerType: (*LangServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _Lang_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Lang_Logout_Handler,
		},
		{
			MethodName: "HeartMsg",
			Handler:    _Lang_HeartMsg_Handler,
		},
		{
			MethodName: "TransRequest",
			Handler:    _Lang_TransRequest_Handler,
		},
		{
			MethodName: "SayHello",
			Handler:    _Lang_SayHello_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TtsRequest",
			Handler:       _Lang_TtsRequest_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamingRecognize",
			Handler:       _Lang_StreamingRecognize_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamingRecTransTTs",
			Handler:       _Lang_StreamingRecTransTTs_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "lang.proto",
}

func init() { proto.RegisterFile("lang.proto", fileDescriptor_lang_4a58467c005c656f) }

var fileDescriptor_lang_4a58467c005c656f = []byte{
	// 1589 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xdf, 0x6e, 0x1b, 0x4d,
	0x15, 0xcf, 0xfa, 0xef, 0xfa, 0x7c, 0x8e, 0xed, 0xcc, 0x97, 0x7e, 0x75, 0xdd, 0x42, 0xd2, 0x6d,
	0x0b, 0x0d, 0x08, 0x53, 0x02, 0x14, 0x54, 0x71, 0xe3, 0x38, 0x9b, 0xd8, 0x92, 0xe3, 0x44, 0xe3,
	0x0d, 0x29, 0x2a, 0xd2, 0x6a, 0x6a, 0x4f, 0xb6, 0x2b, 0xd6, 0xb3, 0xee, 0xcc, 0xb8, 0xc4, 0xbd,
	0x44, 0xdc, 0x20, 0x9e, 0x81, 0x0b, 0x6e, 0x10, 0x42, 0xe2, 0x25, 0x78, 0x32, 0x34, 0x33, 0xbb,
	0xf6, 0xda, 0x49, 0xda, 0x2b, 0x24, 0xee, 0xe6, 0xfc, 0xce, 0x39, 0x73, 0xfe, 0xce, 0xd9, 0xb3,
	0x00, 0x11, 0x61, 0x41, 0x7b, 0xc6, 0x63, 0x19, 0xa3, 0x82, 0x98, 0xc5, 0xc2, 0x99, 0x40, 0xad,
	0x1b, 0x85, 0x94, 0xc9, 0x41, 0x1c, 0x84, 0x0c, 0xd3, 0x8f, 0xa8, 0x01, 0x79, 0x11, 0x4e, 0x9a,
	0xd6, 0xbe, 0xf5, 0xb2, 0x82, 0xd5, 0x11, 0xb5, 0xc0, 0x9e, 0x11, 0x21, 0xfe, 0x18, 0xf3, 0x49,
	0x33, 0xa7, 0xe1, 0x25, 0x8d, 0x10, 0x14, 0x18, 0x99, 0xd2, 0x66, 0x5e, 0xe3, 0xfa, 0xac, 0x6e,
	0x98, 0x92, 0x71, 0xb3, 0x60, 0x6e, 0x98, 0x92, 0xb1, 0xf3, 0x76, 0xc3, 0x8a, 0x50, 0x32, 0x9c,
	0x4a, 0x6d, 0xc5, 0xc6, 0xea, 0x88, 0x1e, 0x42, 0x99, 0x53, 0xe1, 0x0b, 0xc9, 0x13, 0x23, 0x25,
	0x4e, 0xc5, 0x48, 0x72, 0xf4, 0x18, 0x2a, 0x8a, 0x21, 0xe3, 0x3f, 0x50, 0x96, 0xd8, 0xb1, 0x39,
	0x15, 0x9e, 0xa2, 0x9d, 0x3e, 0xd4, 0x97, 0x37, 0xc7, 0x73, 0x79, 0x77, 0x00, 0xa9, 0x93, 0xb9,
	0xdb, 0x4e, 0xe6, 0x57, 0x4e, 0x3e, 0xdb, 0xbc, 0xea, 0x0e, 0x2f, 0x9d, 0x5f, 0xa4, 0x91, 0xf4,
	0x28, 0xe1, 0xf7, 0x98, 0x4b, 0xae, 0xce, 0xad, 0xae, 0xde, 0xd4, 0xba, 0x2b, 0x7e, 0xa5, 0x25,
	0x82, 0xa5, 0x96, 0x08, 0x9c, 0x00, 0x4a, 0x9e, 0x14, 0xca, 0x06, 0x82, 0x82, 0xa4, 0x37, 0x32,
	0x31, 0xa2, 0xcf, 0x0a, 0x53, 0xd5, 0x4c, 0x83, 0x52, 0x67, 0xf4, 0x1d, 0x94, 0x02, 0xca, 0x26,
	0x94, 0xeb, 0xb8, 0x8a, 0x38, 0xa1, 0xd0, 0xf7, 0x00, 0xc8, 0x7c, 0x12, 0xc6, 0xfe, 0x38, 0x9e,
	0x50, 0x5d, 0x98, 0x22, 0xae, 0x68, 0xa4, 0x1b, 0x4f, 0xa8, 0x73, 0x00, 0xb6, 0x36, 0x34, 0x8b,
	0x16, 0x2b, 0xd1, 0x09, 0x91, 0x44, 0x1b, 0xac, 0x26, 0xa2, 0xc7, 0x44, 0x12, 0xe7, 0x18, 0x6c,
	0x8f, 0x13, 0xa6, 0xbd, 0xda, 0x81, 0x82, 0xf0, 0x23, 0xb6, 0x0c, 0x7d, 0xc0, 0x14, 0x24, 0x15,
	0x94, 0x44, 0x21, 0x07, 0x6c, 0xe9, 0x7b, 0x7e, 0xe5, 0xbb, 0xf3, 0x63, 0x80, 0xe4, 0x96, 0xc4,
	0xa4, 0x54, 0x94, 0x9f, 0x89, 0xb1, 0xa2, 0x11, 0x4f, 0x09, 0xff, 0xc3, 0x82, 0x47, 0x23, 0xc9,
	0x29, 0x99, 0x86, 0x2c, 0xc0, 0x74, 0x1c, 0x07, 0x2c, 0xfc, 0x4c, 0x31, 0xfd, 0x38, 0xa7, 0x42,
	0xa2, 0x33, 0x68, 0x88, 0x94, 0xe9, 0x8f, 0x63, 0x76, 0x1d, 0x06, 0xfa, 0x8a, 0x6f, 0x0e, 0xf7,
	0xdb, 0xaa, 0xc3, 0xdb, 0x9b, 0xaa, 0x32, 0x8c, 0x59, 0x57, 0xcb, 0xf5, 0xb6, 0x70, 0x7d, 0xa9,
	0x6b, 0x20, 0xf4, 0x02, 0xb6, 0xd3, 0x4c, 0x31, 0x49, 0x99, 0xd4, 0x91, 0x54, 0x7b, 0x5b, 0xb8,
	0x9a, 0xa4, 0x4b, 0xa3, 0x47, 0xdf, 0xc2, 0xce, 0xca, 0x2a, 0x37, 0xae, 0x38, 0xff, 0xb2, 0xe0,
	0x49, 0xd6, 0x5a, 0xa0, 0x63, 0x34, 0x25, 0xd4, 0xbe, 0x0e, 0xef, 0xf5, 0xf5, 0xe9, 0x6d, 0x5f,
	0x97, 0xda, 0xff, 0x1b, 0x67, 0xff, 0x6d, 0xc1, 0xe3, 0xac, 0x39, 0x65, 0xcd, 0xf3, 0x04, 0xa6,
	0x62, 0x16, 0x33, 0x41, 0xd1, 0x6b, 0x28, 0x70, 0x3a, 0xfe, 0x4a, 0x2e, 0x55, 0x19, 0x8c, 0x7c,
	0x6f, 0x0b, 0x6b, 0x79, 0xb4, 0xb7, 0x56, 0xcc, 0xd4, 0xa1, 0x55, 0x39, 0x95, 0x40, 0xa6, 0xc1,
	0xf2, 0xa9, 0xc0, 0xb2, 0xc5, 0x8e, 0x76, 0x01, 0x65, 0xdd, 0x35, 0xf7, 0x3b, 0xff, 0xcc, 0x41,
	0xeb, 0x7e, 0xf3, 0xc8, 0x81, 0x22, 0xe5, 0x3c, 0xe6, 0x89, 0xbf, 0xd5, 0xd4, 0x5f, 0x22, 0xe7,
	0x02, 0x1b, 0x16, 0x7a, 0xa3, 0x27, 0xcc, 0x3c, 0x92, 0xa2, 0x99, 0xdb, 0xcf, 0x7f, 0xb9, 0x43,
	0xb0, 0x16, 0xc4, 0xa9, 0x02, 0xfa, 0x3d, 0xec, 0x88, 0x19, 0xa5, 0xe3, 0x0f, 0x3e, 0xfd, 0x44,
	0x99, 0xf4, 0xe5, 0x62, 0x66, 0x1e, 0x52, 0xed, 0xf0, 0xd5, 0xd7, 0x72, 0xd3, 0x1e, 0x69, 0x4d,
	0x57, 0x29, 0x7a, 0x8b, 0x19, 0xc5, 0x75, 0xb1, 0x0e, 0x38, 0x03, 0xa8, 0x6f, 0xc8, 0xa0, 0x27,
	0xd0, 0x1c, 0x5d, 0xb8, 0x6e, 0xb7, 0xe7, 0xbb, 0xbf, 0x75, 0x87, 0x9e, 0x7f, 0x39, 0x1c, 0x5d,
	0xb8, 0xdd, 0xfe, 0x49, 0xdf, 0x3d, 0x6e, 0x6c, 0xa1, 0xc7, 0xf0, 0xd0, 0x1d, 0x1e, 0xfb, 0xe7,
	0x27, 0xfe, 0xa8, 0x3f, 0x3c, 0x1d, 0xb8, 0xfe, 0xa5, 0xe7, 0xb9, 0xb8, 0x33, 0xec, 0xba, 0x0d,
	0xcb, 0xf9, 0x4f, 0x6e, 0xbd, 0xb4, 0x1b, 0x9d, 0x84, 0x7e, 0x0a, 0xa5, 0xb5, 0xe6, 0x7b, 0x68,
	0x02, 0xb8, 0xf5, 0x3e, 0x70, 0x22, 0x86, 0x0e, 0xa0, 0x21, 0x42, 0x16, 0x44, 0xd4, 0x9f, 0x4b,
	0x49, 0x39, 0x61, 0x63, 0x33, 0x4b, 0x6d, 0x5c, 0x37, 0xf8, 0x65, 0x0a, 0xa3, 0x1f, 0x42, 0x3d,
	0x64, 0x92, 0xf2, 0x70, 0xea, 0xa7, 0xb9, 0xce, 0x6b, 0xc9, 0x5a, 0x02, 0xe3, 0x24, 0xa1, 0x7b,
	0xf0, 0x8d, 0xe9, 0x13, 0x11, 0xcf, 0x39, 0x4d, 0x3e, 0x16, 0xa6, 0x75, 0x46, 0x0a, 0x41, 0x4f,
	0xa1, 0x9a, 0x34, 0x12, 0xe1, 0x01, 0x95, 0xcd, 0xa2, 0x96, 0x30, 0x4a, 0x9e, 0x86, 0xd0, 0x03,
	0x28, 0x49, 0xa9, 0x47, 0x50, 0x49, 0x33, 0x8b, 0x52, 0xaa, 0x21, 0xa4, 0xe6, 0x89, 0x14, 0x7e,
	0x32, 0x09, 0xcb, 0x66, 0xda, 0x49, 0x29, 0x4e, 0xcd, 0x30, 0x7c, 0x0e, 0x35, 0xc5, 0xce, 0x0c,
	0x44, 0x5b, 0x8b, 0x54, 0xa5, 0x14, 0x9d, 0xe5, 0x4c, 0xfc, 0xbb, 0x75, 0xbb, 0xdf, 0x56, 0xa9,
	0xf9, 0xbf, 0xc8, 0xa1, 0xf3, 0xa7, 0x02, 0xec, 0xdc, 0x76, 0xad, 0x03, 0x36, 0x65, 0xe3, 0x78,
	0x12, 0x32, 0xe3, 0x5c, 0xed, 0xf0, 0xc5, 0x3d, 0xce, 0xb5, 0x75, 0xb8, 0x6e, 0x22, 0x8c, 0x97,
	0x6a, 0xe8, 0x47, 0xb0, 0x23, 0xc8, 0x74, 0x16, 0x51, 0x9f, 0x13, 0x49, 0xfd, 0x0f, 0x94, 0xcb,
	0xcf, 0xda, 0xdb, 0x22, 0xae, 0x1b, 0x06, 0x26, 0x92, 0xf6, 0x14, 0x8c, 0x9e, 0xc1, 0xb6, 0xfa,
	0xf6, 0xcc, 0x49, 0x40, 0x4d, 0x36, 0xcd, 0xa0, 0xaf, 0xa6, 0xa0, 0xca, 0xa6, 0x8a, 0x7e, 0x4a,
	0x6e, 0x7c, 0x12, 0x49, 0xca, 0x19, 0x91, 0xe1, 0x27, 0x2a, 0x92, 0xcf, 0x50, 0x7d, 0x4a, 0x6e,
	0x3a, 0x19, 0x58, 0x89, 0xce, 0x78, 0x7c, 0x4d, 0x58, 0x28, 0x17, 0xfe, 0x75, 0xa8, 0x58, 0xba,
	0xf6, 0x36, 0xae, 0x2f, 0xf1, 0x13, 0x0d, 0xa3, 0xdf, 0x40, 0xf2, 0x92, 0xcc, 0x00, 0xbc, 0x91,
	0xa2, 0x59, 0xd2, 0x0f, 0xfb, 0xdb, 0xe4, 0x49, 0x6a, 0x66, 0xd7, 0xf0, 0x70, 0x4d, 0x64, 0x49,
	0x81, 0x7e, 0x05, 0x4d, 0xca, 0xc8, 0xfb, 0x88, 0xfa, 0x6a, 0x93, 0xf1, 0x65, 0x38, 0xa5, 0x7e,
	0x7c, 0x7d, 0x2d, 0xa8, 0x14, 0xba, 0x23, 0x6c, 0xfc, 0xc0, 0xf0, 0xaf, 0x62, 0x3e, 0xf1, 0xc2,
	0x29, 0x3d, 0x37, 0x4c, 0xe7, 0xaf, 0x16, 0x6c, 0xaf, 0x65, 0x0e, 0x35, 0x61, 0xd7, 0x1d, 0x76,
	0xcf, 0x8f, 0xfb, 0xc3, 0xd3, 0x8d, 0x87, 0x5a, 0x05, 0x7b, 0xd0, 0x1f, 0xba, 0x1d, 0xfc, 0xb3,
	0xd7, 0x0d, 0x0b, 0xd9, 0x50, 0x38, 0x19, 0x74, 0xba, 0x8d, 0x1c, 0xaa, 0x40, 0xf1, 0xec, 0x72,
	0xd0, 0xb9, 0x6a, 0xe4, 0x51, 0x19, 0xf2, 0x9d, 0x33, 0xdc, 0x28, 0x20, 0x80, 0x52, 0xe7, 0x0c,
	0xfb, 0x57, 0x47, 0x8d, 0xa2, 0xd2, 0x3b, 0x3f, 0x3d, 0xf5, 0xcf, 0x2f, 0x2e, 0x47, 0x8d, 0x12,
	0x6a, 0xc1, 0x77, 0x6a, 0x18, 0xbc, 0xf5, 0xaf, 0xfa, 0x5e, 0xcf, 0xef, 0xb9, 0x9d, 0x63, 0x17,
	0xfb, 0x47, 0xbf, 0xf3, 0xdc, 0x46, 0xd9, 0x39, 0x80, 0xed, 0xb5, 0x38, 0x51, 0x13, 0xca, 0xb3,
	0x0f, 0x9c, 0x08, 0x2a, 0x9a, 0xd6, 0x7e, 0xfe, 0x65, 0x05, 0xa7, 0xa4, 0xf3, 0xb7, 0x7b, 0x7a,
	0xda, 0xf4, 0x13, 0x3a, 0x81, 0xea, 0x5a, 0x81, 0x2c, 0x9d, 0x4b, 0x27, 0x9b, 0xcb, 0x8c, 0x52,
	0xa6, 0x68, 0x78, 0x4d, 0x0f, 0x3d, 0x02, 0x3b, 0x14, 0xfe, 0x75, 0xc8, 0x48, 0x94, 0xb4, 0x78,
	0x39, 0x14, 0x27, 0x8a, 0x44, 0x4f, 0xa0, 0x22, 0x24, 0x79, 0x1f, 0x46, 0xa1, 0x5c, 0xe8, 0x46,
	0xc9, 0xe1, 0x15, 0xe0, 0xbc, 0x83, 0x92, 0x99, 0xd8, 0x6a, 0x69, 0xd0, 0xbd, 0x64, 0xe9, 0x1e,
	0xd1, 0x67, 0x15, 0xd7, 0x94, 0x0a, 0x41, 0x82, 0x74, 0x91, 0x4b, 0x49, 0xf4, 0x0c, 0xca, 0x13,
	0x2a, 0x49, 0x18, 0xa9, 0x87, 0xa2, 0x7c, 0xae, 0x18, 0x9f, 0x3b, 0x6c, 0x81, 0x53, 0x8e, 0xf3,
	0x67, 0xf5, 0x75, 0xfe, 0x42, 0x10, 0xe8, 0xfb, 0xc9, 0x97, 0x6b, 0xcc, 0xc3, 0x59, 0xba, 0x86,
	0x64, 0x10, 0xc5, 0xd7, 0x6f, 0x79, 0x42, 0xd3, 0xb7, 0x9b, 0xc3, 0x19, 0x04, 0x3d, 0x87, 0xa2,
	0x6a, 0xa4, 0xd4, 0x87, 0x9a, 0xf1, 0x41, 0x35, 0x4f, 0x9f, 0x5d, 0xc7, 0xd8, 0x30, 0x9d, 0x1b,
	0xb0, 0x53, 0x08, 0xfd, 0x04, 0x40, 0x48, 0xc2, 0xa5, 0xee, 0xbd, 0x64, 0x90, 0x24, 0x6a, 0xc7,
	0x73, 0x4e, 0x74, 0x69, 0x2a, 0x5a, 0x42, 0xb5, 0x1f, 0x3a, 0x50, 0x0f, 0xdb, 0x34, 0xaa, 0x36,
	0x7f, 0x5b, 0xb8, 0x4c, 0x99, 0xee, 0x54, 0x95, 0x3f, 0xbd, 0xae, 0x27, 0x4b, 0x97, 0x3a, 0x3b,
	0xaf, 0x21, 0xdf, 0x61, 0x0b, 0x55, 0x1d, 0xf5, 0xf1, 0xf2, 0xe7, 0x3c, 0x4a, 0x82, 0x2c, 0x2b,
	0xfa, 0x92, 0x47, 0x68, 0x17, 0x8a, 0x9f, 0x48, 0x34, 0x37, 0xb7, 0x57, 0xb1, 0x21, 0x9c, 0x37,
	0x60, 0xa7, 0x06, 0x54, 0x0d, 0x04, 0x1d, 0xc7, 0x6c, 0x22, 0xb4, 0x6e, 0x1e, 0xa7, 0xa4, 0xd2,
	0x65, 0x84, 0xc5, 0x22, 0x19, 0x13, 0x86, 0x70, 0x1c, 0xa8, 0xf6, 0x68, 0x14, 0xc5, 0xe9, 0x06,
	0x94, 0x6e, 0xe2, 0xd6, 0x6a, 0x13, 0x77, 0x7e, 0x00, 0x90, 0xc8, 0xa8, 0x65, 0x30, 0x53, 0x65,
	0x6b, 0xad, 0xca, 0x87, 0x7f, 0x29, 0x40, 0x61, 0xa0, 0xb6, 0xdc, 0x5f, 0x42, 0x51, 0xff, 0x47,
	0xa0, 0x5d, 0x13, 0xfe, 0xfa, 0x0f, 0x4c, 0xeb, 0x2e, 0x54, 0x38, 0x5b, 0xe8, 0xd7, 0x50, 0x32,
	0x9b, 0x3d, 0x7a, 0xb0, 0x21, 0x61, 0x7e, 0x1c, 0x5a, 0x77, 0xc2, 0x46, 0xd3, 0xd6, 0x8b, 0xfb,
	0x99, 0x08, 0xd6, 0x6d, 0xa6, 0x3f, 0x01, 0xad, 0xbb, 0x50, 0xa5, 0xd9, 0x06, 0xc8, 0xec, 0x7f,
	0xc9, 0x56, 0x62, 0x90, 0x56, 0x2d, 0x43, 0xcd, 0xa2, 0x85, 0xb3, 0xf5, 0xca, 0x42, 0x87, 0x50,
	0x4d, 0xd7, 0x6b, 0xad, 0x91, 0xca, 0x24, 0x58, 0xab, 0xb1, 0x46, 0x6b, 0x2d, 0xf4, 0x0e, 0xd0,
	0xed, 0xdd, 0x03, 0xed, 0xdd, 0xbf, 0x95, 0xe8, 0xab, 0x5b, 0x5f, 0x5d, 0xe9, 0x5e, 0x5a, 0xaf,
	0x2c, 0x44, 0x60, 0x77, 0x73, 0x4b, 0x14, 0x9e, 0x27, 0x90, 0xf3, 0x85, 0x85, 0x35, 0xb5, 0x70,
	0xc7, 0x52, 0xbb, 0xb1, 0x65, 0x6a, 0x13, 0x87, 0x60, 0x8f, 0xc8, 0x42, 0xb7, 0x00, 0x42, 0x46,
	0x25, 0xdb, 0x33, 0x69, 0xcc, 0xab, 0x1e, 0x71, 0xb6, 0x8e, 0xf6, 0xa0, 0x11, 0xc6, 0xed, 0x80,
	0xcf, 0xc6, 0xed, 0x39, 0x0b, 0xb5, 0xc0, 0x51, 0x45, 0x5c, 0xc4, 0xe2, 0x42, 0xfd, 0xdb, 0x5e,
	0x58, 0xef, 0x4b, 0xfa, 0x27, 0xf7, 0xe7, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xf3, 0xdb, 0x8f,
	0x60, 0xf2, 0x0e, 0x00, 0x00,
}
